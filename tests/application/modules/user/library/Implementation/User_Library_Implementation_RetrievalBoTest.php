<?php
/**
 * Test class for User_Library_Implementation_RetrievalBo.
 * Generated by PHPUnit on 2011-01-15 at 19:08:02.
 */
class User_Library_Implementation_RetrievalBoTest extends ControllerTestCase
{
	/**
	 * (non-PHPdoc)
	 * @see Framework/PHPUnit_Framework_TestCase::setUp()
	 */
	public function setUp()
	{
		parent::setUp();
	}

	/**
	 * (non-PHPdoc)
	 * @see Framework/PHPUnit_Framework_TestCase::tearDown()
	 */
	public function tearDown()
	{
		parent::tearDown();
	}

	public function testInsert()
	{
		$dao = $this->getMock('User_Library_Implementation_RetrieveDao', array('save'), array(new User_Model_Recover(array('id'=>1,'hashToken'=>sha1('Test1234'),'receiver'=>'jorgeomar.vazquez@gmail.com','expiricyDate'=>date('m-d-Y',strtotime("+3 day")),'attempts'=>0,'disabled'=>0))),'retrieveMockDao',true);
		$dao->expects($this->once())->method('save')->will($this->returnValue(true));
		$retrieveBo = new User_Library_Implementation_RetrievalBo();
		$retrieveBo->setDao($dao);
		$result = $retrieveBo->insert(array('id'=>1,'hashToken'=>sha1('Test1234'),'receiver'=>'jorgeomar.vazquez@gmail.com','expiricyDate'=>date('m-d-Y',strtotime("+3 day")),'attempts'=>0,'disabled'=>0));
		$this->assertTrue($result,'Insert should have returned true');
	}

	public function testUpdate()
	{
		$dao = $this->getMock('User_Library_Implementation_RetrieveDao', array('update'), array(new User_Model_Recover(array('id'=>1,'hashToken'=>sha1('Test1234'),'receiver'=>'jorgeomar.vazquez@gmail.com','expiricyDate'=>date('m-d-Y',strtotime("+3 day")),'attempts'=>1,'disabled'=>0))),'',true);
		$dao->expects($this->once())->method('update')->will($this->returnValue(true));
		$retrieveBo = new User_Library_Implementation_RetrievalBo();
		$retrieveBo->setDao($dao);
		$result = $retrieveBo->update(array('id'=>1,'hashToken'=>sha1('Test1234'),'receiver'=>'jorgeomar.vazquez@gmail.com','expiricyDate'=>date('m-d-Y',strtotime("+3 day")),'attempts'=>0,'disabled'=>0));
		$this->assertTrue($result,'Insert should have returned true');
	}

	public function testFindById()
	{
		$dao = $this->getMock('User_Library_Implementation_RetrieveDao', array('findById'), array(1),'',true);
		$stub = array('id'=>1,'hashToken'=>sha1('Test1234'),'receiver'=>'jorgeomar.vazquez@gmail.com','expiricyDate'=>date('m-d-Y',strtotime("+3 day")),'attempts'=>0,'disabled'=>0);
		/**
		 * @link http://stackoverflow.com/questions/311485/how-to-test-a-second-parameter-in-a-phpunit-mock-object
		 * ->with($this->equalTo(1))
		 */
		$dao->expects($this->once())->method('findById')->with($this->equalTo(1))->will($this->returnValue(new User_Model_Recover($stub)));
		$retrieveBo = new User_Library_Implementation_RetrievalBo();
		$retrieveBo->setDao($dao);
		$result = $retrieveBo->findById(1);
		$this->assertTrue($result!=false,'Insert should have returned true');
		$this->assertEquals(new User_Model_Recover($stub),$result,'We expected a similar object');
	}

	public function testDelete()
	{
		$dao = $this->getMock('User_Library_Implementation_RetrieveDao', array('delete'), array(1),'',true);
		$dao->expects($this->once())->method('delete')->with($this->equalTo(1))->will($this->returnValue(true));
		$retrieve = new User_Library_Implementation_RetrievalBo();
		$retrieve->setDao($dao);
		$result = $retrieve->delete(1);
		$this->assertTrue($result,'Delete should have returned true');
	}

	public function testRecoverPassword()
	{
		$transport = new Email_File(APPLICATION_TEST.DIRECTORY_SEPARATOR.'tests'.DIRECTORY_SEPARATOR.'fakemails'.DIRECTORY_SEPARATOR.'email.eml');
		Zend_Mail::setDefaultTransport($transport);
		$retrieveBo = new User_Library_Implementation_RetrievalBo();
		$stub = array();
		$retrieveBo->setEmailAgent($transport);
		$result = $retrieveBo->recoverPassword($stub);
		$this->assertFalse($result,'We expect a false result');
		$this->assertEquals(array('msg'=>'missingUsername','type'=>'error'),$retrieveBo->getMessageState(),'We expect an error indicating that the username is missing');

		$stub = array('username'=>'jwhoo');
		$result = $retrieveBo->recoverPassword($stub);
		$this->assertFalse($result,'We expect a false result');
		$this->assertEquals(array('msg'=>'missingEmail','type'=>'error'),$retrieveBo->getMessageState(),'We expect an error indicating that the email is missing');

		$stub = array('username'=>'joz','emailAddress'=>'none.vazquez@gmail.com');
		$dao = $this->getMock('User_Library_Implementation_Dao', array('findByKey'), array('search'=>array('emailAddress'=>'none.vazquez@gmail.com','username'=>'joz')),'fakeDaoTwo',true);
		$retrieveBo->setUserDao($dao);
		$dao->expects($this->once())->method('findByKey')->with($this->equalTo(array('search'=>array('emailAddress'=>'none.vazquez@gmail.com','username'=>'joz'))))->will($this->returnValue(null));
		$result = $retrieveBo->recoverPassword($stub);
		$this->assertFalse($result,'We expect a false result');
	}

	public function testRecoverPasswordCallsDao()
	{
		//	A good scenario , we generate two mocks , one for the user dao  and the second for the RetrieveDao that interacts with a different entity
		$stub = array('username'=>'jvazquez','emailAddress'=>'jorgeomar.vazquez@gmail.com');
		$searchStub = array('search'=>array('emailAddress'=>'jorgeomar.vazquez@gmail.com','username'=>'jvazquez'));
		$user = new User_Model_User($stub);

		$rDao = $this->getMock('User_Library_Implementation_RetrieveDao',array('save'),array($user),'',true);
		$rDao->expects($this->once())->method('save')->will($this->returnValue(true));
		$this->assertNotNull($rDao,'The mock is null');

		$dao = $this->getMock('User_Library_Implementation_Dao', array('findByKey'),$searchStub,'',true);
		$dao->expects($this->once())
			->method('findByKey')
			->with($this->equalTo($searchStub))
			->will($this->returnValue(array($user)));

		$agent = $this->getMock('Zend_Mail_Transport_Abstract',array('send','_sendMail'),array(),'',true);
		$agent->expects($this->once())
				  ->method('send')
				  ->will($this->returnValue(true));

		$retrieveBo = new User_Library_Implementation_RetrievalBo();
		$retrieveBo->setEmailAgent($agent);
		$retrieveBo->setDao($rDao);
		$retrieveBo->setUserDao($dao);
		$result = $retrieveBo->recoverPassword($stub);
		$this->assertTrue($result!=false,'We expected a result different than false');
	}

	public function testGenerateRandomString()
	{
		$bo = new User_Library_Implementation_RetrievalBo();
		$string = $bo->generateUniqueToken();
		$this->assertEquals (strlen($string),40,'The lenght of sha1 changed');
	}

	public function testYieldForgotPasswordEmail()
	{
		$transport = new Email_File(APPLICATION_TEST.DIRECTORY_SEPARATOR.'tests'.DIRECTORY_SEPARATOR.'fakemails'.DIRECTORY_SEPARATOR.'email.eml');
		Zend_Mail::setDefaultTransport($transport);
		$bo = new User_Library_Implementation_RetrievalBo();
		$bo->setEmailAgent($transport);
		$bo->setDao(new User_Library_Implementation_RetrieveDao());
		$stub = array('username'=>'jvazquez','emailAddress'=>'jorgeomar.vazquez@gmail.com');
//		$this->assertType('Zend_Mail', $bo->yieldForgotPasswordEmail(new User_Model_User($stub)) );
		$this->assertInstanceOf('Zend_Mail', $bo->yieldForgotPasswordEmail(new User_Model_User($stub)) );
//		$this->assertInternalType($expected, $actual);
	}

	public function testVerifyToken()
	{
		//	A rejected token due to fake record
		$service = new User_Library_Implementation_RetrievalBo();
		$search = array('search'=>array('hashToken'=>sha1('test')));
		$dao = $this->getMock('User_Library_Implementation_RetrieveDao', array('findByKey'), array($search),'',true);
		$dao->expects($this->once())->method('findByKey')->with($this->equalTo($search))->will($this->returnValue(null));
		$service->setDao($dao);
		$result = $service->verifyToken(sha1('test'));
		$this->assertFalse($result,'We expect a fake result');

		unset($service);

		//	A valid token that exists and is clean
		Zend_Date::setOptions(array('format_type' => 'php'));
		$service = new User_Library_Implementation_RetrievalBo();
    	$date = new Zend_Date();
    	$date->add(3,Zend_Date::DAY);
		$rmodelStub = array('id'=>1,'hashToken'=>sha1('test'),'receiver'=>'jorgeomar.vazquez@gmail.com','expiricyDate'=>$date->toString('Y-m-d'),'attempts'=>0,'disabled'=>0);
		$dao = $this->getMock('User_Library_Implementation_RetrieveDao', array('findByKey'), array($search),'',true);
		$dao->expects($this->once())->method('findByKey')->with($this->equalTo($search))->will($this->returnValue(array(new User_Model_Recover($rmodelStub))));
		$service->setDao($dao);
		$result = $service->verifyToken(sha1('test'));
		$this->assertTrue($result,'We expect a valid result');

		//	And a token that was disabled due to multiple attempts
		unset($service);

		Zend_Date::setOptions(array('format_type' => 'php'));
		$service = new User_Library_Implementation_RetrievalBo();
    	$date = new Zend_Date();
    	$date->add(3,Zend_Date::DAY);
		$rmodelStub = array('id'=>1,'hashToken'=>sha1('test'),'receiver'=>'jorgeomar.vazquez@gmail.com','expiricyDate'=>$date->toString('Y-m-d'),'attempts'=>4,'disabled'=>1);
		$dao = $this->getMock('User_Library_Implementation_RetrieveDao', array('findByKey'), array($search),'',true);
		$dao->expects($this->once())->method('findByKey')->with($this->equalTo($search))->will($this->returnValue(array(new User_Model_Recover($rmodelStub))));
		$service->setDao($dao);
		$result = $service->verifyToken(sha1('test'));
		$this->assertFalse($result,'We expect a false result');
		$this->assertEquals($service->getMessageState(),array('msg'=>'tokenNotLongerValid','type'=>'error'));

		// And a basic check
		unset($service);
		$service = new User_Library_Implementation_RetrievalBo();
		$result = $service->verifyToken(null);
		$this->assertFalse($result,'We expect a null result');
		$this->assertEquals($service->getMessageState(),array('msg'=>'missingToken','type'=>'error'));
	}

	public function testGetResetPasswordForm()
	{
		$service = new User_Library_Implementation_RetrievalBo();
		$form = $service->getResetPasswordForm();
		$this->assertNotNull($form,"The expected result is null");
	}

	public function testPerformReset()
	{
		$date = $this->fetchDate();
		$hashToken = sha1('Test');
		$args = array('hashToken'=>$hashToken,'password'=>'ding_dong');
		$service = new User_Library_Implementation_RetrievalBo();

		/**
		 * Weaving the daos
		 * Build a RetrieveDao and look him up
		 */
		$dao = $this->getMock('User_Library_Implementation_RetrieveDao', array('findByKey'), array( array('search'=>array('hashToken'=>$hashToken) ) ) ) ;
		$dao->expects($this->any())
			->method('findByKey')
			->with( $this->equalTo( array('search'=>array('hashToken'=>$hashToken) ) ) )
			->will( $this->returnValue( array( new User_Model_Recover( array('id'=>1,'hashToken'=>$hashToken,'attempts'=>0,'disabled'=>0,'expiricyDate'=>$date,'receiver'=>'jorgeomar.vazquez@gmail.com') ) ) ) );
		
		$fakeUser = array ( new User_Model_User( array('password'=>sha1('dog') ,'id'=>1,'emailAddress'=>'jorgeomar.vazquez@gmail.com') ) );
		$userDao = $this->getMock('User_Library_Implementation_Dao',array('findByKey','saveCollection'),array( array('search'=>array('emailAddress'=>'jorgeomar.vazquez@gmail.com') ),array(new User_Model_User( array('password'=>$hashToken ,'id'=>1) ) ) ) );
		$userDao->expects($this->once())
				->method('findByKey')
				->with( $this->equalTo(array('search'=>array('emailAddress'=>'jorgeomar.vazquez@gmail.com' ) ) ) )
				->will( $this->returnValue( $fakeUser ) );

		$userDao->expects( $this->once() )
				->method('saveCollection')
				->with( $this->equalTo( $fakeUser ) )
				->will( $this->returnValue( true ) );
		$service->setDao($dao);
		$service->setUserDao($userDao);

		$this->assertTrue($service->resetPassword($args),'We expect a true result');
		//	And a null arg
		$args = array();
		$this->assertFalse( $service->resetPassword($args) ,'We expected a false result');
		$this->assertEquals(array('msg'=>'missingToken','type'=>'error'),$service->getMessageState(),'Error while retrieving message state');
	}

	public function testDisableToken()
	{
		$date = $this->fetchDate();
		$hashToken = sha1('Test');
		$args = array('hashToken'=>$hashToken,'expiricyDate'=>$date,'id'=>1,'disabled'=>0);
		$service = new User_Library_Implementation_RetrievalBo();
		$dao = $this->getMock('User_Library_Implementation_RetrieveDao', array('update','findByKey'), array(new User_Model_Recover($args) , array('search'=>array('hashToken'=>$hashToken)) ) );
		$dao->expects($this->once())
			->method('findByKey')
			->with( $this->equalTo( array ( 'search' => array('hashToken'=>$hashToken) ) ) )
			->will( $this->returnValue(array(new User_Model_Recover($args))));
		$args['disabled'] = 1;
		$dao->expects($this->once())
			->method('update')
			->with( $this->equalTo(new User_Model_Recover($args)))
			->will($this->returnValue(true));
		$service->setDao($dao);
		$this->assertTrue($service->disableToken($hashToken),'We expect a disabled token');
	}
	
	/**
	 * Helper to retrieve the date , will return the Date of today with +3 days
	 * @return Zend_Date
	 */
	private function fetchDate()
	{
		Zend_Date::setOptions(array('format_type' => 'php'));
		$service = new User_Library_Implementation_RetrievalBo();
    	$date = new Zend_Date();
    	$date->add(3,Zend_Date::DAY);
    	return $date;
	}
}
?>
